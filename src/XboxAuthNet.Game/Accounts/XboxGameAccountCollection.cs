using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using XboxAuthNet.Game.SessionStorages;

namespace XboxAuthNet.Game.Accounts;

public class XboxGameAccountCollection<T> : ICollection<T> 
    where T : XboxGameAccount
{
    private readonly List<T> _accounts = new();

    public int Count => _accounts.Count;
    public bool IsReadOnly => false;

    public IEnumerable<T> GetAccounts()
    {
        // 1) Ignore accounts which has empty Identifier
        // 2) Remove duplicated accounts which has same Identifier
        // 2-1) If two accounts has same identifier, remove olds and take the most recent one
        // 3) Order by the most recently accessed account

        return _accounts
            .Where(account => !string.IsNullOrEmpty(account.Identifier))
            .GroupBy(account => account.Identifier)
            .Select(group => group.OrderByDescending(account => account.LastAccess).First())
            .OrderByDescending(account => account.LastAccess);
    }

    public T GetAccount(string identifier)
    {
        var account = getAccount(identifier);
        if (account == null)
            throw new Exception();
        return account;
    }

    public bool TryGetAccount(string identifier, out XboxGameAccount account)
    {
        account = getAccount(identifier)!;
        return account != null;
    }

    private T? getAccount(string identifier)
    {
        return _accounts
            .Where(account => account.Identifier == identifier)
            .OrderByDescending(account => account.LastAccess)
            .FirstOrDefault();
    }

    public void Add(T account)
    {
        _accounts.Add(account);
    }

    public bool Remove(T account)
    {
        return _accounts.Remove(account);
    }

    public bool RemoveAccount(string identifier)
    {
        var findIndex = _accounts.FindIndex(0, account => account.Identifier == identifier);
        if (findIndex == -1)
            return false;

        _accounts.RemoveAt(findIndex);
        return true;
    }

    public void Clear()
    {
        _accounts.Clear();
    }

    public bool Contains(T toFind)
    {
        return _accounts.Exists(account => account.Equals(toFind));
    }

    public void CopyTo(T[] array, int startIndex)
    {
        if (array == null)
            throw new ArgumentNullException(nameof(array));
        if (startIndex < 0)
            throw new ArgumentOutOfRangeException(nameof(startIndex), "The start index cannot be negative.");
        
        var accounts = GetAccounts().ToArray();
        if (startIndex + accounts.Length > array.Length)
            throw new ArgumentException("The number of elements in the source collection exceeds the available space in the array."); // generated by chatGPT
        
        Array.Copy(accounts, 0, array, startIndex, accounts.Length);
    }

    public IEnumerable<ISessionStorage> ToSessionStorages()
    {
        return GetAccounts().Select(account => account.SessionStorage);
    }

    public IEnumerator<T> GetEnumerator()
    {
        return GetAccounts().GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}